#!/bin/sh

#{{{ Copyright
# Studioware package install script
# Copyright 2011 David Woodfall <dave@dawoodfall.net>
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#}}}
#{{{ Init
init()
{
    APPNAME="studiopkg"
    VERSION="5.6b22"
    TMPROOT=$(mktemp -d -p /tmp $APPNAME-XXXXXX) || exit
    trap "cleanup" HUP INT ABRT QUIT SEGV TERM KILL PIPE STOP TSTP
  
    case "$( uname -m )" in
        i?86) ARCH="" ;;
        x86_64) ARCH=64 ;;
    esac

    QUEUE=$TMPROOT/queue
    TMPQ=$TMPROOT/tmp-queue
    PKGLIST=$TMPROOT/pkglist
    CWD=$(pwd)
    LOGFILE=/tmp/$APPNAME.log
    rm -f $LOGFILE
    WGET="wget --no-check-certificate"
    INSTALL="upgradepkg --reinstall --install-new"
    CONFDIR=/etc/$APPNAME/
    mkdir -p $CONFDIR
    MAINURL="http://www.studioware.org"
    CONF=$CONFDIR$APPNAME.conf
    touch $CONF
    source $CONF
    if [ -z "$CHECKGPG" ]; then
        echo "CHECKGPG not set in $CONF..."
        echo "Setting to ON. You can change this later by editing $CONF"
        echo "CHECKGPG=ON" >> $CONF
        CHECKGPG="ON"
        echo -n "Press enter to continue"
        read <&1
    fi
    TOOLURL="$MAINURL/files/tools/$APPNAME"
    PKGSERVER="$MAINURL/files/packages/slackware$ARCH-$SWVERSION"
    SBSERVER="$MAINURL/files/slackbuilds/$SWVERSION"
    CACHEDIR=/var/cache/$APPNAME/$SWVERSION
    mkdir -p $CACHEDIR
    FILELIST=$CACHEDIR/FILELIST.TXT
    SLACKBUILDS=$CACHEDIR/SLACKBUILDS.TXT
    CHECKSUMS=$CACHEDIR/CHECKSUMS.md5
    STUDIOKEY="Studioware <info@studioware.org>"
    GPG="gpg --verify"
    YESNO=0
    NOGUI=0
}
#}}}
#{{{ Cleanup and exit
cleanup()
{
    rm -rf $TMPROOT

    if [ -n "$LOG" ]; then
        echo "========================================================" >> $LOGFILE
        cat $LOGFILE
    fi

    exit
}
#}}}
#{{{ Test if string $1 contains $2
contains()
{
    for opt in $1
    do
        [[ "$opt" = "$2" ]] && return 0
    done

    return 1
}
#}}}
#{{{ Flags
getflags()
{
    FLAGS=$*
    contains "$FLAGS" -y && { YESNO=1; NOGUI=1; FLAGS=${FLAGS/-y}; }
    contains "$FLAGS" -n && { NOGUI=1; FLAGS=${FLAGS/-n}; }
    contains "$FLAGS" --yes && { YESNO=1; NOGUI=1; FLAGS=${FLAGS/--yes}; }
    contains "$FLAGS" --no-gui && { NOGUI=1; FLAGS=${FLAGS/--no-gui}; }
    contains "$FLAGS" --log && { LOG="tee -a $LOGFILE" ; FLAGS=${FLAGS/--log}; }

    if [ -n "$LOG" ]; then    
        echo "STUDIOPKG SUMMARY" >> $LOGFILE
        echo "========================================================" >> $LOGFILE
        echo "Command line: $(basename $0) $*" >> $LOGFILE
        echo "========================================================" >> $LOGFILE
    fi
    
    CMD=$(echo $FLAGS | cut -d' ' -f1)
    ARG=$(echo $FLAGS | cut -d' ' -f2-)
    [[ "$ARG" = "$CMD" ]] && unset ARG

    contains "$CMD" --update          && { update; cleanup; }
    contains "$CMD" --search          && { search $ARG; cleanup; }
    contains "$CMD" --install-all     && { install_all $ARG; cleanup; }
    contains "$CMD" --install         && { local_queue $ARG; cleanup; }
    contains "$CMD" --remove          && { remove $ARG; cleanup; }
    contains "$CMD" --upgrade-all     && { upgrade_all; cleanup; }
    contains "$CMD" --upgrade         && { upgrade $ARG; cleanup; }
    contains "$CMD" --clean-system    && { clean_system; cleanup; }
    contains "$CMD" --delete-cache    && { delete_cache; cleanup; }
    contains "$CMD" --new             && { new_packages; cleanup; }
    contains "$CMD" --gpg             && { import_gpg; cleanup; }
    contains "$CMD" --queue           && { get_queue $ARG; cleanup; }
    contains "$CMD" --help            && { usage; cleanup; }
    contains "$CMD" --version         && { echo $APPNAME $VERSION;unset LOG;cleanup; }
    contains "$CMD" -g && { import_gpg; cleanup; }
    contains "$CMD" -s && { search $ARG; cleanup; }
    contains "$CMD" -u && { update; cleanup; }
    contains "$CMD" -i && { local_queue $ARG; cleanup; }
    contains "$CMD" -r && { remove $ARG; cleanup; }
    contains "$CMD" -l && { latest; cleanup; }
    contains "$CMD" -q && { get_queue $ARG; cleanup; }
    contains "$CMD" -h && { usage; cleanup; }
    contains "$CMD" -v && { echo $APPNAME $VERSION;unset LOG; cleanup; }

    unset LOG
    usage
    echo
    echo "Unknown command: $CMD"
    cleanup
}
#}}}
#{{{ Usage
usage()
{
    unset LOG
    cat << EOF
$APPNAME <command> [arguments]

$APPNAME --clean-system                    remove all studioware packages dialog
$APPNAME --delete-cache                    delete all cached packages
$APPNAME --install, -i package1, package2..install packages
$APPNAME --install, -i < <queuefile>       install packages from file
$APPNAME --install-all                     install all packages
$APPNAME --remove, -r <package>            remove package
$APPNAME --search, -s <name>               search for package name or part name
$APPNAME --update, -u                      syncs with file server
$APPNAME --upgrade <package>               upgrade package
$APPNAME --upgrade-all                     upgrade all packages
$APPNAME --queue, -q <package>             download and install queue
$APPNAME --new                             download and install new packages
$APPNAME --latest, -l                      checks for latest version of $APPNAME
$APPNAME --gpg, -g                         import the Studioware GPG key
$APPNAME --help, -h                        help
$APPNAME --version, -v                     give version and exit

Extra options:

--no-gui    disables dialog and uses text input
--yes       assumes yes to answers (also implies --no-gui)
--log       creates studiopkg.log in current directory

Files:

/etc/$APPNAME/$APPNAME.conf

This file contains the mirror URL and should be edited for Slackware version
and GPG checking.
EOF
}
#}}}
#{{{ latest
latest()
{
    cd /tmp
    unset LOG
  
    LATEST=$(curl -s $TOOLURL/LATEST)
    REMVERS=$(echo $LATEST | cut -db -f1)
    REMBUILD=$(echo $LATEST | cut -db -f2)

    echo "Installed version: $VERSION. Latest version: $LATEST."

    if [ "$VERSION" != "$LATEST" ]; then
        echo -n "Newer version available. Download it? (Y/n) "
        read REPLY <&1

        case "$REPLY" in
            'y'|'Y'|'')
                PKG=$APPNAME-$REMVERS-noarch-${REMBUILD}daw.txz
                ASC=$APPNAME-$REMVERS-noarch-${REMBUILD}daw.txz.asc
                MD5=$APPNAME-$REMVERS-noarch-${REMBUILD}daw.md5
                $WGET -q -O $PKG $TOOLURL/$PKG 
                $WGET -q -O $MD5 $TOOLURL/$MD5
                $WGET -q -O $ASC $TOOLURL/$ASC

                echo "Package saved to /tmp"
                echo "Checking md5... "

                md5sum -c $MD5

                if [ $? != 0 ]; then
                    cleanup
                fi

                if [ "$CHECKGPG" = "ON" ]; then
                    echo "Checking gpg..."
                    # try to surpress the authority warning...
                    GPGOUT=$($GPG $ASC $PKG 2>&1 | head -n2)

                    if [ -n "$(echo $GPGOUT | grep -i 'not found')" ]; then
                        echo "$GPGOUT"
                        echo "Did you import the Studioware key with 'studiopkg -g|gpg'?"
                        cleanup
                    elif [ -n "$(echo $GPGOUT | grep -i 'bad signature')" ]; then
                            echo "$GPGOUT"
                            cleanup
                    else
                        echo "$GPGOUT"
                    fi
                fi


                echo
                echo -n "Upgrade now? (Y/n) "
                read UREPLY <&1

                case "$UREPLY" in
                    'y'|'Y'|'')
                        $INSTALL $PKG 
                        ;;
                    *)
                        cleanup
                        ;;
                esac
                ;;
            *)
                cleanup
                ;;
        esac
    fi
}
# }}}
#{{{ Update
update()
{ 
    unset LOG
    cd $CACHEDIR || cleanup
    $WGET -O FILELIST.TXT $PKGSERVER/FILELIST.TXT 
    $WGET -O CHECKSUMS.md5 $PKGSERVER/CHECKSUMS.md5 
    $WGET -O SLACKBUILDS.TXT $SBSERVER/SLACKBUILDS.TXT 
    cleanup
}
#}}}
#{{{ Local Queue
local_queue()
{
    cd $CACHEDIR || { echo "No cache exists. Did you run --update?"; cleanup; }
    [[ ! -r $FILELIST ]] && { echo "No filelist. Did you run --update?"; cleanup; }

    unset pkgs
    cl="$@"

    if [ -z "$cl" ]; then
        cat /dev/stdin | sed 's/,/\n/g;/^$/d' | tr -d ' ' > $QUEUE
    else
        echo "$cl" | sed 's/,/\n/g' | tr -d ' ' > $QUEUE
    fi

    exec <&1
    list_pkgs
}
#}}}
#{{{ New packages
new_packages()
{
    cd $CACHEDIR || { echo "No cache exists! Did you run update?"; cleanup; }
    [[ ! -r $FILELIST ]] && { echo "No filelist! Did you run update?"; cleanup; }

    echo -n "" > $QUEUE
    echo "Looking for new packages..."

    # Begin with a list of all se packages
    ls /var/log/packages/*se | cut -d/ -f5 | rev | cut -d- -f4- | rev > $TMPQ

    grep txz$ $FILELIST | cut -d/ -f4 | rev | cut -d. -f2- \
        | cut -d- -f4- | rev | while read PKG
    do
        [[ -z "$(grep ^$PKG$ $TMPQ)" ]] && echo $PKG >> $QUEUE
    done

    if [ -z "$(cat $QUEUE)" ]; then
        echo "No new packages."
        unset LOG
        rm -rf $LOGFILE
        cleanup;
    fi
    
    TITLE="Choose new packages to install"
    list_pkgs
}
#}}}
#{{{ Get Queue
get_queue()
{
    cd $CACHEDIR || { echo "No cache exists! Did you run update?"; cleanup; }

    if [ ! -r $FILELIST ]; then { echo "No filelist! Did you run update?"; \
        cleanup; } fi

    cd $TMPROOT || cleanup

    case "$1" in
        'audio'|'video'|'photo'|'full')
            curl -fs $SBSERVER/queues/$1.sqf > $QUEUE
            ;;

        *)
            CAT=$(grep -i /$1.tar.gz$ $SLACKBUILDS | cut -d/ -f2-4)
            APP=$(echo $CAT | cut -d/ -f3)

            if [ -n "$CAT" ]; then
                curl -fs $SBSERVER/$CAT/$APP.sqf > $QUEUE

                if [ $? != 0 ]; then
                    echo "Queue $1.sqf not found."
                    echo "Will try application directly."
                    local_queue "$@"
                fi
            else
                if [ ! -r $CWD/$1 ] && [ ! -r $1 ]; then
                    echo "Queue $1 not found."
                    cleanup
                else
                    if [ -r "$CWD/$1" ]; then
                        cat $CWD/$1 > $QUEUE
                    else
                        cat $1 > $QUEUE
                    fi

                fi
            fi
            ;;
    esac

    list_pkgs
}
#}}}
#{{{ Make queue
make_queue()
{
    cd $TMPROOT
    let CNT=1
    touch $TMPQ

    while read line
    do
        TOP=$(head -n $((CNT-1)) $TMPQ)

        if [ -n "$TOP" ]; then
            echo "$TOP" > $TMPQ
        fi

        # subqueue
        if [ -z "$(echo $line | cut -d@ -f1)" ] && [ -n "$line" ]; then
            SUB=$(echo $line | cut -d@ -f2)

            if [ -n "$SUB" ]; then
                if [ ! -r $CWD/$SUB.sqf ] && [ ! -r $SUB.sqf ]; then
                    CAT=$(grep -i /$SUB.tar.gz$ $SLACKBUILDS | cut -d/ -f2-4)

                    if [ -n "$CAT" ]; then
                        $WGET -O $SUB.sqf $SBSERVER/$CAT/$SUB.sqf 
                    else
                        case $SUB in
                            'full'|'audio'|'video'|'photo')
                                $WGET -O $SUB.sqf $SBSERVER/queues/$SUB.sqf 
                                ;;
                            *) 
                                echo "Queue $SUB.sqf not found." 
                                cleanup
                            ;;
                        esac
                    fi
                else
                    if [ -r "$CWD/$SUB.sqf" ]; then
                        cat $CWD/$SUB.sqf > $SUB.sqf
                    fi
                fi

                SWAP=$(cat $SUB.sqf)
                echo "$SWAP" >> $TMPQ
                let CNT=$(wc -l $TMPQ | awk '{print $1}')+1
                unset SWAP
            fi
        else
            echo $line >> $TMPQ
            let CNT=$((CNT+1))
        fi
    done < $1
}
#}}}
#{{{ Do Dialog
do_dialog()
{
    [[ -z "$LIST" ]] && { echo "Package list is empty."; cleanup; }

    echo -n "" > $TMPQ

    for PKG in $PKGS
    do
        echo $PKG >> $TMPQ
        PRGNAM=$(echo $PKG | grep txz | rev | cut -d- -f4- | rev)
        ARCH=$(echo $PKG | grep txz | rev | cut -d- -f2 | rev)
        EXISTING=$(find /var/log/packages/ -name $PRGNAM\-\*\-$ARCH\-\*[^se])
        [[ -n "$EXISTING" ]] && EXISTS=$EXISTS" "$(basename $EXISTING)
    done
    
    # Reverse the order
    unset PKGS

    for P in $(tac $TMPQ)
    do
        PKGS=$PKGS$P" "
    done

    if [ -n "$EXISTS" ]; then
        echo "WARNING! You have the following package(s) already installed:"
        echo 
        for P in $EXISTS; do echo $P; done
        echo 
        echo "If you continue, the package(s) may be removed or replaced."
        echo "You can choose which ones to keep in the next step."
        echo "Press [enter] to continue."

        [[ $YESNO -eq 0 ]] && read
    fi

    if [ -n "$LOG" ]; then
        echo "Package list:">> $LOGFILE
        for P in $PKGS; do echo $P >> $LOGFILE; done

        if [ -n "$EXISTS" ]; then
            echo "========================================================" >> $LOGFILE
            echo "WARNING! You have the following package(s) already installed:" >> $LOGFILE
            echo "If you continue, the package(s) may be removed or replaced." >> $LOGFILE
            echo >> $LOGFILE
            for P in $EXISTS; do echo $P >> $LOGFILE; done
        fi
    fi

    let rows=$(stty size | cut -f1 -d' ')-4
    let cols=$(stty size | cut -f2 -d' ')
    let mrows=$((rows-6))

    if [ $NOGUI -eq 0 ] && [ -n "$(echo $TITLE | grep remove)" ]; then
        dialog --separate-output --title "Package List" --backtitle "$APPNAME $VERSION" \
            --checklist "$TITLE" \
            $rows $cols $mrows $LIST 2> $PKGLIST
        CHOICE=$?
    elif [ $NOGUI -eq 0 ] && [ -n "$(echo $TITLE | grep upgrade)" ]; then
        dialog --separate-output --title "Package List" --backtitle "$APPNAME $VERSION" \
            --checklist "$TITLE" \
            $rows $cols $mrows $LIST 2>$PKGLIST
        CHOICE=$?
    elif [ $NOGUI -eq 0 ] && [ -n "$(echo $TITLE | grep new)" ]; then
        dialog --separate-output --title "Package List" --backtitle "$APPNAME $VERSION" \
            --checklist "$TITLE" \
            $rows $cols $mrows $LIST 2>$PKGLIST
        CHOICE=$?
    elif [ $NOGUI -eq 0 ]; then
        dialog --separate-output --title "Package List" --backtitle "$APPNAME $VERSION" \
            --help-button --help-label "Clear Inst'd" --help-status \
            --checklist "$TITLE" \
            $rows $cols $mrows $LIST 2>$PKGLIST
        CHOICE=$?
    else
        for P in $PKGS
        do
            echo $P | tr -d ' ' >> $PKGLIST
            echo $P
        done

        if [ $YESNO -eq 0 ]; then
            echo "Install? (Y/n)"
            read <&1
            
            REPLY=$(echo $REPLY | tr 'a-z' 'A-Z')
            [[ "$REPLY" = "" ]] && REPLY="Y"
            [[ "$REPLY" = "Y" ]] && CHOICE=0 || cleanup
        else
            CHOICE=0
        fi
    fi
}
#}}}
#{{{ List Packages
list_pkgs()
{
    exec <&1
    unset PKGS
    unset LIST
    unset MISSING

    echo "Building queue..."

    while true
    do
        if [ -n "$(grep @ $QUEUE)" ]; then
            echo -n > $TMPQ
            make_queue $QUEUE
            cat $TMPQ > $QUEUE
        else
            break
        fi
    done

    echo -n > $TMPQ

    while read name
    do
        if [ ! $(grep -x $name $TMPQ) ]; then
            echo $name >> $TMPQ
        fi
    done < $QUEUE

    cat $TMPQ > $QUEUE

    while read name
    do
        pkg=$(grep -i /$name-[^-]*-[^-]*-[^-]*txz$ $FILELIST | cut -d/ -f4)

        if [ -n "$pkg" ]; then
            LIST=$LIST" "$pkg" "$name" ""on "
            PKGS=$pkg" "$PKGS
        else
            MISSING=$name" "$MISSING
        fi
    done < $QUEUE

    if [ -n "$MISSING" ]; then
        echo "The following are in the queue, but not in the server file list:"
        echo $MISSING
        sleep 3
        #cleanup
    fi

    [[ -z "$TITLE" ]] && TITLE="Choose packages to install:"
    do_dialog

    if [ $CHOICE -eq 2 ] && $(sed -i 's%^HELP %%g' $PKGLIST); then
        clear_installed
        list_pkgs
    fi

    [[ $CHOICE -ne 0 ]] && cleanup
    [[ -z "$(cat $PKGLIST)" ]] && cleanup

    install_pkgs
}
#}}}
#{{{ Clear Installed
clear_installed()
{
    while read newpkg
    do
        for o in $(ls /var/log/packages/$newpkg* 2>/dev/null)
        do
            oldpkg=$(echo $o | cut -d/ -f5 | rev | cut -d- -f4- | rev)

            if [ -n "$(echo $oldpkg | grep upgraded)" ]; then
                oldpkg="NULL"
            fi

            if [ "$newpkg" == "$oldpkg" ]; then
                sed -i "/$newpkg$/d" $QUEUE
            fi
        done
    done < $QUEUE

    if [ $(wc -l $QUEUE | awk '{print $1}') = "0" ]; then
        echo "No packages to install."
        cleanup
    fi
}
#}}}
#{{{ Install Everything
install_all()
{
    cd $CACHEDIR || { echo "No cache exists! Did you run update?"; cleanup; }
    [[ ! -r $FILELIST ]] && { echo "No filelist! Did you run update?"; cleanup; }
    curl -fs $SBSERVER/queues/full.sqf > $QUEUE
    list_pkgs
}
##}}}
#{{{ Remove
remove()
{
    cl=$(echo $* | tr -s ',' ' ')

    for p in $cl
    do
        for i in /var/log/packages/$p*se
        do
            inname=$(basename $i | rev | cut -d- -f4- | rev)
            if [ "$inname" = "$p" ]; then
                LIST=$LIST" "$(basename $i)" "$inname" ""on "
                PKGS=$inname" "$PKGS
            fi
        done
    done

    TITLE="Choose packages to remove:"
    do_dialog

    [[ $CHOICE -ne 0 ]] && cleanup
    [[ -z "$(cat $PKGLIST)" ]] && cleanup

    for i in "$(cat $PKGLIST)"
    do
        removepkg $i
    done
}
#}}}
#{{{ Clean system
clean_system()
{
    pkgs="$(ls /var/log/packages/*se 2>/dev/null)"

    for i in $pkgs
    do
        base=$(basename $i)
        shortname=$(echo $base | rev | cut -d- -f4- | rev)
        if [ -n "$i" ]; then
            LIST=$LIST" "$base" "$shortname" ""on "
            PKGS=$base" "$PKGS
        fi
    done

    if [ -z "$LIST" ]; then 
        echo "No packages found."
        cleanup
    fi

    TITLE="Choose packages to remove:"
    do_dialog

    [[ $CHOICE -ne 0 ]] && cleanup
    [[ -z "$(cat $PKGLIST)" ]] && cleanup

    for i in "$(cat $PKGLIST)"
    do
        removepkg $i
    done
}
#}}}
#{{{ Upgrade
upgrade()
{
    cd $CACHEDIR || { echo "No cache exists. Did you run update?"; cleanup; }
    [[ ! -r $FILELIST ]] && { echo "No filelist. Did you run update?"; cleanup; }

    for i in $*
    do
        sepkgs="$sepkgs $(ls -1 /var/log/packages/$i*se 2>/dev/null)"
    done

    [[ -z "$sepkgs" ]] && { echo "No packages to upgrade."; cleanup; }

    for pkg in $sepkgs
    do
        shortname=$(basename $pkg | rev | cut -d- -f4- | rev)
        iversion=$(basename $pkg | cut -d/ -f3)
        nversion=$(grep -i /$shortname-[^-]*-[^-]*-[^-]*txz$ $FILELIST | \
            cut -d/ -f4 | rev | cut -d. -f2- | rev)
        package=$(grep -i /$shortname-[^-]*-[^-]*-[^-]*txz$ $FILELIST | \
            cut -d/ -f4)
      
        if [ "$iversion" != "$nversion" ] && [ -n "$package" ]; then
            LIST=$LIST" "$package" "$shortname" ""on "
            PKGS="package $PKGS"
        fi
    done

    [[ -z "$LIST" ]] && { echo "All up to date."; cleanup; }
    TITLE="Choose packages to upgrade:"
    do_dialog

    [[ $CHOICE -ne 0 ]] && cleanup
    [[ -z "$(cat $PKGLIST)" ]] && cleanup

    install_pkgs
}
#}}}
#{{{ Upgrade All
upgrade_all()
{
    cd $CACHEDIR || { echo "No cache exists! Did you run update?"; cleanup; }
    [[ ! -r $FILELIST ]] && { echo "No filelist! Did you run update?"; cleanup; }

    echo "Looking for packages to upgrade..."

    sepkgs="$(ls -1 /var/log/packages/*se 2>/dev/null)"

    [[ -z "$sepkgs" ]] && { echo "No packages to upgrade."; cleanup; }

    for pkg in $sepkgs
    do
        shortname=$(basename $pkg | rev | cut -d- -f4- | rev)
        iversion=$(basename $pkg | cut -d/ -f3)
        nversion=$(grep -i /$shortname-[^-]*-[^-]*-[^-]*txz$ $FILELIST | \
            cut -d/ -f4 | rev | cut -d. -f2- | rev)
        package=$(grep -i /$shortname-[^-]*-[^-]*-[^-]*txz$ $FILELIST | \
            cut -d/ -f4)
      
        if [ "$iversion" != "$nversion" ] && [ -n "$package" ]; then
            LIST=$LIST" "$package" "$shortname" ""on "
            PKGS="$package $PKGS"
        fi
    done

    if [ -z "$LIST" ]; then 
        echo "No packages to upgrade"
        unset LOG
        unset LOGFILE
        cleanup
    fi

    TITLE="Choose packages to upgrade:"
    do_dialog

    [[ $CHOICE -ne 0 ]] && cleanup
    [[ -z "$(cat $PKGLIST)" ]] && cleanup

    install_pkgs
}
#}}}
#{{{ Check md5
check_md5()
{
    let TRIES=0
    echo "Checking md5..."
    md5sum -c $1.md5
    exit=$?

    while [ $exit -ne 0 ]
    do
        echo "Checksums don't match. Did you run '-u|update' first?" 
        echo "You may need to delete the cache." 
        echo "(r)edownload, (a)bort, (c)ontinue or (s)kip?" 
        
        if [ $YESNO -eq 1 ]; then
            let TRIES=$TRIES+1
            [[ $TRIES -gt 2 ]] && { echo "Tried 3 times. Skipping."; return 2; }
            echo "Redownloading ($TRIES)" 
            ANS="r"
        else
            read ANS <&1
        fi

        if [ "$ANS" = "r" ]; then
            rm -f $1
            $WGET -O $1 $2 2>&1 
            echo -n "Checking md5..."
            md5sum -c $1.md5
            exit=$?

            [[ $exit -eq 0 ]] && return 0
        fi

        [[ "$ANS" = "a" ]] && cleanup;
    done
}
#}}}
#{{{ Check GPG
check_gpg()
{
    if [ ! "$(which gpg 2>/dev/null)" ]&&[ "$CHECKGPG" = "ON" ]; then
        echo "gpg package not found"
        echo "Please install the gnupg package to check signatures and reenable"
        echo "CHECKGPG in $CONF"
        echo -n "(a)bort or (c)ontinue? "
        read <&1
        
        if [ "$REPLY" != "c" ]; then cleanup; fi

        echo "Continuing without gpg check..."
        sed -i 's/CHECKGPG=.*/CHECKGPG=OFF/g' $CONF
        return 0
    else
        if [ "$CHECKGPG" = "ON" ]; then
            echo "Checking gpg..."
            # try to surpress the authority warning...
            GPGOUT=$($GPG $1.asc $1 2>&1 | head -n2)

            if [ -n "$(echo $GPGOUT | grep -i 'not found')" ]; then
                echo "$GPGOUT"
                echo "Did you import the Studioware key with 'studiopkg -g|gpg'?"
                cleanup
            elif [ -n "$(echo $GPGOUT | grep -i 'bad signature')" ]; then
                    echo "$GPGOUT"
                    cleanup
            else
                echo "$GPGOUT"
                return 0
            fi
        else
            return 0
        fi
    fi

    return 1
}
# }}}
#{{{ Install Packages
install_pkgs()
{
    exec <&1
    if [ -n "$LOG" ]; then
        echo "========================================================" >> $LOGFILE
    fi

    while read TXZ
    do
        REMOTE=$(grep .*$TXZ$ $FILELIST | awk '{print $9}' | cut -d'/' -f2-)
        let exit=99

        while [[ $exit -ne 0 ]]
        do
            $WGET -O $TXZ.md5 $PKGSERVER/$REMOTE.md5 
            $WGET -O $TXZ.asc $PKGSERVER/$REMOTE.asc 

            if [ ! -r "$TXZ" ]; then
                $WGET -O $TXZ $PKGSERVER/$REMOTE 
            fi

            check_md5 $TXZ $PKGSERVER/$REMOTE 
            let exit=$?

            [[ $exit -eq 2 ]] && break
            [[ $exit -eq 1 ]] && cleanup

            check_gpg $TXZ 

            [[ $exit -eq 1 ]] && cleanup
            
            $INSTALL $TXZ 2>&1

            if [ -n "$LOG" ]; then
                echo "Installed/Upgraded: $TXZ" >> $LOGFILE
            fi
        done
    done < $PKGLIST
    cleanup
}
#}}}
#{{{ Import gpg key
import_gpg()
{
    [[ ! -e ~/.gnupg ]] && mkdir ~/.gnupg

    cd $TMPROOT || cleanup
    $WGET -O gpgkey ${PKGSERVER}/GPG-KEY || cleanup
    gpg --yes --batch --delete-key "$STUDIOKEY"
    gpg --import gpgkey
    echo "Studioware GPG key added"
    cleanup
}
#}}}
#{{{ Search
search()
{
    unset LOG
    cd $CACHEDIR || { echo "No cache exists! Did you run update?"; cleanup; }
    if [ ! -r $FILELIST ]; then { echo "No filelist! Did you run update?"; \
        cleanup; } fi

    for p in $(grep -i "$1" $FILELIST | egrep txz$ | awk '{print $9}')
    do
        shortname=$(echo $p | cut -d'/' -f4 | rev | cut -d- -f4- | rev)
        dir=$(echo $p | cut -d'/' -f2)
        installed=$(basename $(ls /var/log/packages/$shortname-*se 2>/dev/null) \
            2>/dev/null | rev | cut -d- -f4- | rev)

        found=$(echo $p | cut -d'/' -f2-)

        in="[Not Installed]	$found"
        if [ "$shortname" = "$installed" ]; then
            in="[Installed]	$found"; fi
        echo "$in"
    done
}
#}}}
#{{{ Delete Cache
delete_cache()
{
    unset LOG
    cd $CACHEDIR || cleanup
    find . -name "*txz" -exec rm -f {} \;
    find . -name "*md5" -exec rm -f {} \;
    find . -name "*asc" -exec rm -f {} \;
    find . -iname "*txt" -exec rm -f {} \;
    echo "Cache Deleted"
    unset LOG
    cleanup
}
#}}}
init
getflags "$@"

# vim: tw=0
